import Control.Monad.State
import Data.Int
-- Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

-- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

-- By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

-- fib 0 = 0
-- fib 1 = 1
-- fib n = fib (n -1) + fib (n - 2)


fib :: Int64 -> Int64
fib n = flip evalState (0,1,0) $ do
  _ <- forM [0..(n-1)] $ \_ -> do
    (a,b,c) <- get
    if a+b > 4000000 then
      put (a,b,c)
      else
      if even (a+b) then
        put (b,a+b, c+a+b)
        else
        put (b, a+b, c)
  (_,_,c) <- get
  return c


-- user can solve via binary search with random input... once the same value is returned twice, you have the write answer (unless you use very large input numbers in which case you could get negative integers) (over 40 will give the answer)... answer is 4613732
main :: IO ()
main = do
  upperBoundInput <- getLine
  let upperBound = read upperBoundInput ::Int64
  -- let listOfFibs = takeWhile (>= upperBound) [ fib  | i <- [1..]]
  -- foldl'

  -- let theAnswer = foldl (\base numToTest ->
  --                           if numToTest `rem` 5 == 0 || numToTest `rem` 3 == 0 then
  --                             base + numToTest
  --                           else
  --                             base
  --                           ) 0 [1..999]
  putStrLn $ "upper bound is " ++ show upperBound
  putStrLn $ "The answer is " ++ show (fib upperBound)

-- we could write a more complete solution with a pair of functions is like this :
-- fib :: Int64 -> (Int64, Int64)
-- where the first number in the return tuple is the sum, and the second is the largest number reached,

-- binarySearch :: Int
-- this function would call fib over and over, adjusting up and down until the number returned was over 4,000,00 .. perhaps not ideal...it would probably be possible to move that process into the state monad where we could make use of previous state to speed up the computation
